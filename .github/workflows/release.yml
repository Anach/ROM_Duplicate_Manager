name: Build and Release
on:
  push:
    tags: ['v*']

env:
  APP_NAME: ROM.Duplicate.Manager

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: windows-latest
            platform: win
            extension: .exe
            archive: zip
          - os: ubuntu-latest
            platform: linux
            extension: .AppImage
            archive: tar.gz
          - os: macos-latest
            platform: macos
            extension: .app
            archive: tar.gz

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Get version from tag
      id: version
      run: |
        set -e
        set -x
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "clean_version=${VERSION//[^0-9.]/}" >> $GITHUB_OUTPUT
      shell: bash

    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pyinstaller

    - name: Build Windows EXE
      if: matrix.platform == 'win'
      run: |
        pyinstaller --onefile --windowed --name="${{ env.APP_NAME }}" run.py

    - name: Build Linux AppImage
      if: matrix.platform == 'linux'
      run: |
        set -e
        VERSION="${{ steps.version.outputs.clean_version }}"
        APPDIR="AppDir"
        APPIMAGE_NAME="${{ env.APP_NAME }}-$VERSION.AppImage"

        python -m pip install --quiet pillow

        pyinstaller --onefile --name="${{ env.APP_NAME }}" run.py

        if [ ! -f "dist/${{ env.APP_NAME }}" ]; then
          echo "ERROR: dist/${{ env.APP_NAME }} not found!" >&2
          exit 1
        fi

        rm -rf "$APPDIR"
        mkdir -p "$APPDIR/usr/bin" \
          "$APPDIR/usr/share/applications" \
          "$APPDIR/usr/share/icons/hicolor/256x256/apps"

        cp "dist/${{ env.APP_NAME }}" "$APPDIR/usr/bin/${{ env.APP_NAME }}"

        cat <<'EOF' | sed 's/^        //' > "$APPDIR/AppRun"
        #!/bin/bash
        HERE="$(dirname "$(readlink -f "$0")")"
        exec "$HERE/usr/bin/${{ env.APP_NAME }}" "$@"
        EOF
        chmod +x "$APPDIR/AppRun"

        cat <<'EOF' | sed 's/^        //' > "$APPDIR/${{ env.APP_NAME }}.desktop"
        [Desktop Entry]
        Type=Application
        Name=${{ env.APP_NAME }}
        Exec=${{ env.APP_NAME }}
        Icon=${{ env.APP_NAME }}
        Categories=Utility;
        EOF
        cp "$APPDIR/${{ env.APP_NAME }}.desktop" "$APPDIR/usr/share/applications/"

        python - "$APPDIR/usr/share/icons/hicolor/256x256/apps/${{ env.APP_NAME }}.png" pacman_icon.ico <<'PY'
        if True:
            from PIL import Image
            import sys

            out_path = sys.argv[1]
            ico_path = sys.argv[2]

            with Image.open(ico_path) as img:
                img.save(out_path, format="PNG")
        PY

        wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
        chmod +x appimagetool

        APPIMAGE_EXTRACT_AND_RUN=1 ./appimagetool "$APPDIR" "dist/$APPIMAGE_NAME"

    - name: Build macOS App
      if: matrix.platform == 'macos'
      run: |
        pyinstaller --onefile --windowed --name="${{ env.APP_NAME }}" run.py
        APP_PATH="dist/${{ env.APP_NAME }}.app"
        DMG_PATH="dist/${{ env.APP_NAME }}.dmg"

        if [ ! -d "$APP_PATH" ]; then
          echo "ERROR: $APP_PATH not found!" >&2
          exit 1
        fi

        rm -f "$DMG_PATH"
        hdiutil create -volname "${{ env.APP_NAME }}" -srcfolder "$APP_PATH" -ov -format UDZO "$DMG_PATH"
        hdiutil verify "$DMG_PATH"

    - name: Create release archive
      id: archive
      run: |
        VERSION="${{ steps.version.outputs.clean_version }}"
        PLATFORM="${{ matrix.platform }}"

        if [ "${{ matrix.platform }}" = "win" ]; then
          FILENAME="${{ env.APP_NAME }}.v.$VERSION.zip"
          ARCHIVE_CMD="7z a"
        elif [ "${{ matrix.platform }}" = "linux" ]; then
          FILENAME="${{ env.APP_NAME }}.v.$VERSION.linux.tar.gz"
          APPIMAGE_FILENAME="${{ env.APP_NAME }}-$VERSION.AppImage"
          ARCHIVE_CMD="tar -czf"
        else
          FILENAME="${{ env.APP_NAME }}.v.$VERSION.macos.tar.gz"
          ARCHIVE_CMD="tar -czf"
        fi

        mkdir -p release

        echo "Contents of dist/:"
        ls -l dist/

        if [ "${{ matrix.platform }}" = "win" ]; then
          if [ ! -f "dist/${{ env.APP_NAME }}.exe" ]; then
            echo "ERROR: dist/${{ env.APP_NAME }}.exe not found!" >&2
            exit 1
          fi
          cp "dist/${{ env.APP_NAME }}.exe" release/
        elif [ "${{ matrix.platform }}" = "linux" ]; then
          if [ -z "${APPIMAGE_FILENAME:-}" ]; then
            echo "ERROR: APPIMAGE_FILENAME not set!" >&2
            exit 1
          fi
          if [ ! -f "dist/$APPIMAGE_FILENAME" ]; then
            echo "ERROR: dist/$APPIMAGE_FILENAME not found!" >&2
            exit 1
          fi
          cp "dist/$APPIMAGE_FILENAME" release/
        else
          if [ -d "dist/${{ env.APP_NAME }}.app" ]; then
            cp -r "dist/${{ env.APP_NAME }}.app" release/
          elif [ -f "dist/${{ env.APP_NAME }}" ]; then
            cp "dist/${{ env.APP_NAME }}" release/
          else
            echo "ERROR: No macOS app or binary found in dist/!" >&2
            exit 1
          fi
        fi

        cp README.md release/
        cp CHANGELOG.md release/
        cp LICENSE release/

        echo "Version: $VERSION" > release/VERSION.txt
        echo "Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> release/VERSION.txt
        echo "Platform: ${{ matrix.platform }}" >> release/VERSION.txt
        echo "Git Commit: ${{ github.sha }}" >> release/VERSION.txt

        echo "Contents of release/:"
        ls -l release/

        cd release

        if [ -e "../$FILENAME" ] || [ -d "../$FILENAME" ]; then
          rm -rf "../$FILENAME"
        fi

        if [ "${{ matrix.platform }}" = "win" ]; then
          7z a "../$FILENAME" *
        else
          tar -czf "../$FILENAME" *
        fi

        cd ..
        ARCHIVE_PATH="$PWD/$FILENAME"

        echo "Contents of workspace after archiving:"
        ls -l

        if [ ! -f "$ARCHIVE_PATH" ]; then
          echo "Archive $ARCHIVE_PATH was not created!" >&2
          exit 1
        fi
        if [ -d "$ARCHIVE_PATH" ]; then
          echo "Archive $ARCHIVE_PATH is a directory, not a file!" >&2
          exit 1
        fi

        echo "filename=$FILENAME" >> $GITHUB_OUTPUT
        echo "filepath=$PWD/$FILENAME" >> $GITHUB_OUTPUT
      shell: bash

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: release-binaries-${{ matrix.platform }}
        path: ${{ steps.archive.outputs.filepath }}

  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Download Windows artifact
      uses: actions/download-artifact@v4
      with:
        name: release-binaries-win
        path: artifacts/release-binaries

    - name: Download Linux artifact
      uses: actions/download-artifact@v4
      with:
        name: release-binaries-linux
        path: artifacts/release-binaries

    - name: Download macOS artifact
      uses: actions/download-artifact@v4
      with:
        name: release-binaries-macos
        path: artifacts/release-binaries

    - name: Get version
      id: version
      run: |
        VERSION=${GITHUB_REF#refs/tags/v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Generate checksums
      run: |
        cd artifacts/release-binaries
        find . -type f \( -name "*.zip" -o -name "*.tar.gz" \) -print0 \
          | sort -z \
          | xargs -0 sha256sum > SHA256SUMS

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        name: "ROM Duplicate Manager v${{ steps.version.outputs.version }}"
        body_path: CHANGELOG.md
        files: |
          artifacts/release-binaries/*.zip
          artifacts/release-binaries/*.tar.gz
          artifacts/release-binaries/SHA256SUMS
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
